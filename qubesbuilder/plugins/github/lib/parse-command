#!/usr/bin/python3 --
import sys, base64

prefix = b"-----BEGIN PGP SIGNED MESSAGE-----\nHash: "
sig_start = b"-----BEGIN PGP SIGNATURE-----\n\n"
sig_end = b"\n-----END PGP SIGNATURE-----\n"
shortest_sig = sig_start + b"""
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
=AAAA""" + sig_end
shortest_input = prefix + b"""SHA256

Build-template\x20a\n""" + shortest_sig

def check_base64(untrusted_bytes: bytes) -> None:
    for i in untrusted_bytes:
        if ((0x41 <= i <= 0x5A) or # A-Z
            (0x61 <= i <= 0x7A) or # a-z
            (0x30 <= i <= 0x39) or # 0-9
            (i == 0x2F) or # '/'
            (i == 0x2B)): # '+'
            pass
        else:
            raise ValueError('invalid base64 character')

def check_command(untrusted_command: bytes) -> None:
    if len(untrusted_command) > 255:
        raise ValueError('command too long')
    last_c = 0x20
    for i in untrusted_command:
        if ((0x41 <= i <= 0x5A) or # A-Z
            (0x61 <= i <= 0x7A) or # a-z
            (0x30 <= i <= 0x39) or # 0-9
            (i == 0x5F) or # '_'
            (i == 0x2E)):
            pass
        elif ((i == 0x2D) or # '-'
              (i == 0x20)): # ' '
            if last_c == 0x20:
                raise ValueError('Double spaces or space-dash in command')
        else:
            raise ValueError('invalid character in command')
        last_c = i
    if not (untrusted_command.startswith(b'Build-template ') or
            untrusted_command.startswith(b'Upload ')):
        raise ValueError('Unknown command')
    if untrusted_command[-1] <= 0x20:
        raise ValueError('Trailing whitespace in command forbidden')

def check_one_signature_packet(untrusted_binary_sig: bytes, hash_str: bytes) -> None:
    """
    Check that a byte string is exactly one OpenPGP signature packet.
    The contents of the packet are not checked.
    """
    untrusted_first_byte = untrusted_binary_sig[0]
    if not (untrusted_first_byte & 0x80):
        raise ValueError('first bit zero')
    packet_length = 0
    if untrusted_first_byte & 0x40:
        # new-format packet
        tag = untrusted_first_byte & 0x3F
        untrusted_first_byte = untrusted_binary_sig[1]
        if untrusted_first_byte < 192:
            packet_length = untrusted_first_byte
            len_bytes = 1
        elif untrusted_first_byte < 224:
            packet_length = (((lenlen - 192) << 8) +
                             untrusted_binary_sig[1] + 192)
            len_bytes = 2
        elif untrusted_first_byte == 255:
            packet_length = 0
            len_bytes = 5
            for i in untrusted_binary_sig[2:6]:
                packet_length = packet_length << 8 | i
        else:
            raise ValueError('unsupported partial-length packet')
    else:
        # old-format packet
        len_bytes = 1 << (untrusted_first_byte & 0x3)
        tag = (untrusted_first_byte >> 2) & 0xF
        if len_bytes > 4:
            raise ValueError('forbidden indefinite-length packet')
        for i in untrusted_binary_sig[1:len_bytes + 1]:
            packet_length = packet_length << 8 | i
    if packet_length != len(untrusted_binary_sig) - len_bytes - 1:
        raise ValueError('bad signature length')
    if tag != 2:
        raise ValueError('packet is not a signature')
    if untrusted_binary_sig[len_bytes + 1] != 4:
        raise ValueError('only version 4 signatures allowed')
    if untrusted_binary_sig[len_bytes + 2] != 1:
        raise ValueError('expected signature of type 1, got something else')
    hash_alg = untrusted_binary_sig[len_bytes + 4]
    if hash_alg < 8 or hash_alg > 10:
        raise ValueError('unsupported hash algorithm')
    if hash_str != (b'SHA256', b'SHA384', b'SHA512')[hash_alg - 8]:
        raise ValueError('hash algorithm mismatch')

def reconstruct_armored_sig(untrusted_binary_crc24: bytes, untrusted_b64: bytes) -> bytes:
    """
    Reconstruct an armored signature from the components
    """
    untrusted_array = [sig_start[:-1]]
    untrusted_encoded = base64.b64encode(untrusted_b64)
    untrusted_array += (untrusted_encoded[i:i+64] for i in range(0, len(untrusted_encoded), 64))
    untrusted_array += [b'=' + base64.b64encode(untrusted_binary_crc24), sig_end[1:]]
    return b'\n'.join(untrusted_array)

def main(command_file, sig_file) -> None:
    def parse_command_end(untrusted_input: bytes) -> bytes:
        if not untrusted_input.endswith(sig_end):
            raise ValueError('junk after end of message')
        if untrusted_input[-35:-33] != b'\n=':
            raise ValueError('Missing CRC')
        untrusted_crc24 = untrusted_input[-33:-29]
        check_base64(untrusted_crc24)
        return base64.b64decode(untrusted_crc24)

    untrusted_input = sys.stdin.buffer.read(65536)
    if sys.stdin.buffer.read(1):
        raise Exception('Failed to read to end of file')
    if len(untrusted_input) < len(shortest_input):
        raise ValueError('input too short')
    if not untrusted_input.startswith(prefix):
        raise ValueError('not an inline signed message')
    if untrusted_input[41:49] not in (b'SHA256\n\n', b'SHA384\n\n', b'SHA512\n\n'):
        raise ValueError('bad hash algorithm')
    hash_str = untrusted_input[41:47]

    untrusted_binary_crc24 = parse_command_end(untrusted_input)

    untrusted_command, untrusted_sig = untrusted_input[49:].split(b'\n', 1)
    check_command(untrusted_command)
    if len(untrusted_sig) < len(shortest_sig):
        raise ValueError('sig too short')
    if not untrusted_sig.startswith(sig_start):
        raise ValueError('Invalid start of signature')

    # Parse the base64 data
    must_be_last = False
    untrusted_binary = []
    untrusted_base64_body = untrusted_sig[len(sig_start):-35]
    for i in untrusted_base64_body.split(b'\n'):
        if must_be_last:
            raise ValueError('bad end of file')
        len_i = len(i)
        if len_i > 64:
            raise ValueError('base64 line longer than 64 bytes')
        if not i or len_i % 4:
            raise ValueError('bad base64 line')
        if len_i < 64:
            must_be_last = True
        if i[-1] == ord('='):
            must_be_last = True
            if i[-2] == ord('='):
                check_base64(i[:-2])
                if i[-3] not in (65, 81, 103, 119):
                    raise ValueError('bad base64 line (bad byte before padding)')
            elif i[-2] not in {48, 52, 56, 65, 69, 73, 77, 81, 85, 89, 99, 103, 107, 111, 115, 119}:
                raise ValueError('bad base64 line (bad byte before padding)')
            else:
                check_base64(i[:-1])
        else:
            check_base64(i)
        untrusted_binary.append(base64.b64decode(i))

    untrusted_sig_to_write = b''.join(untrusted_binary)
    check_one_signature_packet(untrusted_sig_to_write, hash_str)
    untrusted_armored_sig_to_write = reconstruct_armored_sig(untrusted_binary_crc24, untrusted_sig_to_write)
    assert untrusted_armored_sig_to_write == untrusted_sig, "Didn't round-trip!"
    with open(sig_file, 'wb') as s, open(command_file, 'wb') as c:
        s.write(untrusted_armored_sig_to_write)
        s.flush()
        c.write(untrusted_command)
        c.flush()

if __name__ == '__main__':
    main(sys.argv[1], sys.argv[2])
